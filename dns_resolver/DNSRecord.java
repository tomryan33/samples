import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.Arrays;
import java.util.Calendar;
import java.util.HashMap;

/**
 * DNS Record Object
 * @author Ryan Clayton
 * Description: This is the record object for the DNS Message.  This object can decode a request record
 *              from an input stream of bytes and re-encode a record back into an output stream of bytes.
 *
 * Methods:
 *  DNSRecord decodeRecord(ByteArrayInputStream input, DNSMessage message);
 *  boolean timestampValid();
 *  void writeBytes(ByteArrayOutputStream os, HashMap<String, Integer> domainNameLocations);
 *  public String toString();
 */
public class DNSRecord {

    /**
     * This method decodes records that come in through an input stream of bytes, and converts them into
     * object variables.
     * @param in stream of bytes from the original request.
     * @param message the message object used to read the domain name.
     * @return a record object with all the record information.
     * @throws IOException throws any errors with input stream.
     */
    public static DNSRecord decodeRecord(ByteArrayInputStream in, DNSMessage message) throws IOException {
        DNSRecord record = new DNSRecord();                     // Create new record object
        record.name_ = message.readDomainName(in);              // Decode the domain name
        record.type_ = DNSHeader.getNBytes(in, 2);              // Get the type from the next 2 bytes
        record.rClass_ = DNSHeader.getNBytes(in, 2);            // Get the R class from the next 2 bytes
        record.ttl_ = DNSHeader.getNBytes(in, 4);               // Get the time to live from the next 4 bytes
        record.rLength_ = DNSHeader.getNBytes(in, 2);           // Get the record length from the next 2 bytes

        record.rData_ = new byte[record.rLength_];              // Create a byte array to store the record data
        for (int i = 0; i < record.rLength_; i++){
            record.rData_[i] = (byte) in.read();                // Store each byte onto the new byte array
        }

        record.deathTime_ = Calendar.getInstance();
        record.deathTime_.add(Calendar.SECOND, record.ttl_);    // Store the death time for this record

        return record;                                          // Return the record object
    }

    /**
     * This method gets the current time and checks if it has passed the death time.
     * @return true if the death time is before the current time, false if it is after.
     */
    public boolean timestampValid() {
        Calendar time = Calendar.getInstance();
        return time.before(deathTime_);
    }

    /**
     * This method write the variables of this object to a byte array.
     * @param os the output stream where we will write the bytes to.
     * @param domainNameLocations hash map contain the address of any previous occurrence of the domain in the
     *                            message.
     * @throws IOException throws any errors with output stream.
     */
    public void writeBytes(ByteArrayOutputStream os, HashMap<String, Integer> domainNameLocations) throws IOException {
        DNSMessage.writeDomainName(os, domainNameLocations, name_); // Write either the domain or its pointer
        os.write(DNSHeader.toBytes(type_, 2));                      // Write the type
        os.write(DNSHeader.toBytes(rClass_, 2));                    // Write the R class
        os.write(DNSHeader.toBytes(ttl_, 4));                       // Write the time to live
        os.write(DNSHeader.toBytes(rLength_, 2));                   // Write the record length
        os.write(rData_);                                           // Write the record data
    }

    /**
     * -*- Method generated by the IDE. -*-
     * Convert the question variables into a human-readable string.
     * @return a string representing the question object.
     */
    @Override
    public String toString() {
        return "DNSRecord{" +
                "name_=" + DNSMessage.octectsToString(name_) +
                ", type_=" + type_ +
                ", rClass_=" + rClass_ +
                ", ttl_=" + ttl_ +
                ", rLength_=" + rLength_ +
                ", rData_=" + Arrays.toString(rData_) +
                '}';
    }

    /**
     * Object Variables:
     * Disclaimer: Definitions pulled straight from the 1987 "DOMAIN NAMES - IMPLEMENTATION AND SPECIFICATION"
     *             specification guide: https://www.ietf.org/rfc/rfc1035.txt
     *
     * name_: a domain name to which this resource record pertains.
     * type_: two octets containing one of the RR type codes.  This field specifies the meaning of the data in
     *        the RDATA field.
     * rClass_: two octets which specify the class of the data in the RDATA field.
     * ttl_: a 32 bit unsigned integer that specifies the time interval (in seconds) that the resource record
     *       may be cached before it should be discarded.  Zero values are interpreted to mean that the RR can
     *       only be used for the transaction in progress, and should not be cached.
     * rLength_: an unsigned 16 bit integer that specifies the length in octets of the RDATA field.
     * rData_: a variable length string of octets that describes the resource.  The format of this information
     *         varies according to the TYPE and CLASS of the resource record. For example, the if the TYPE is A
     *         and the CLASS is IN, the RDATA field is a 4 octet ARPA Internet address.
     * deathTime_: a calendar object storing the time when the record is no longer valid.
     */
    private String[] name_;
    private int type_, rClass_, ttl_, rLength_;
    private byte[] rData_;
    private Calendar deathTime_;

}
