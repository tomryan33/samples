import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Objects;

/**
 * DNS Question Object
 * @author Ryan Clayton
 * Description: This is the question object for the DNS Message.  This object can decode a request question
 *              from an input stream of bytes and re-encode a question back into an output stream of bytes.
 *
 * Methods:
 *  DNSQuestion decodeQuestion(ByteArrayInputStream input, DNSMessage message);
 *  void writeBytes(ByteArrayOutputStream os, HashMap<String, Integer> domainNameLocations);
 *  boolean equals(Object o);
 *  public int hashCode();
 *  public String toString();
 */
public class DNSQuestion {

    /**
     * This method decodes questions that come in through a input stream of bytes, and converts them into
     * object variables.
     * @param in stream of bytes from the original request.
     * @param message the message object used to read the domain name.
     * @return a question object with all the question information.
     * @throws IOException throws any errors with input stream.
     */
    public static DNSQuestion decodeQuestion(ByteArrayInputStream in, DNSMessage message) throws IOException {
        DNSQuestion question = new DNSQuestion();           // Create a new question object

        question.domain_ = message.readDomainName(in);      // Decode the domain name
        question.qType_ = DNSHeader.getNBytes(in, 2);       // Get the Q type from the next two bytes
        question.qClass_ = DNSHeader.getNBytes(in, 2);      // Get the q class from the next two bytes

        return question;                                    // return the question object
    }

    /**
     * This method write the variables of this object to a byte array.
     * @param os the output stream where we will write the bytes to.
     * @param domainNameLocations hash map contain the address of any previous occurrence of the domain in the
     *                            message.
     * @throws IOException throws any errors with output stream.
     */
    public void writeBytes(ByteArrayOutputStream os, HashMap<String, Integer> domainNameLocations) throws IOException {
        DNSMessage.writeDomainName(os, domainNameLocations, domain_);   // Write either the domain or its pointer
        os.write(DNSHeader.toBytes(qType_, 2));                         // Write the Q Type
        os.write(DNSHeader.toBytes(qClass_, 2));                        // Write the Q Class
    }

    /**
     * -*- Method generated by the IDE. -*-
     * Compare two question objects.
     * @param o the rhs object to be compared.
     * @return true/false if the two objects are equal.
     */
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        DNSQuestion that = (DNSQuestion) o;
        return qType_ == that.qType_ && qClass_ == that.qClass_ && Arrays.equals(domain_, that.domain_);
    }

    /**
     * -*- Method generated by the IDE. -*-
     * @return a hash code for the object.
     */
    @Override
    public int hashCode() {
        int result = Objects.hash(qType_, qClass_);
        result = 31 * result + Arrays.hashCode(domain_);
        return result;
    }

    /**
     * -*- Method generated by the IDE. -*-
     * Convert the question variables into a human-readable string.
     * @return a string representing the question object.
     */
    @Override
    public String toString() {
        return "DNSQuestion{" +
                "domain_=" + DNSMessage.octectsToString(domain_) +
                ", qType_=" + qType_ +
                ", qClass_=" + qClass_ +
                '}';
    }

    /**
     * Object Variables:
     * Disclaimer: Definitions pulled straight from the 1987 "DOMAIN NAMES - IMPLEMENTATION AND SPECIFICATION"
     *             specification guide: https://www.ietf.org/rfc/rfc1035.txt
     *
     *  domain_: a domain name represented as a sequence of labels, where each label consists of a length octet
     *           followed by that number of octets.  The domain name terminates with the zero length octet for
     *           the null label of the root.  Note that this field may be an odd number of octets; no padding
     *           is used.
     *  qType_: a two octet code which specifies the type of the query. The values for this field include all
     *          codes valid for a TYPE field, together with some more general codes which can match more than
     *          one type of RR.
     *  qClass_: a two octet code that specifies the class of the query. For example, the QCLASS field is IN
     *           for the Internet.
     */
    private String[] domain_;
    private int qType_, qClass_;

}